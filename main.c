#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <getopt.h>
#include <stdio.h>
#include <dlfcn.h>
#include <errno.h>
#include <math.h>

typedef double (*mathematical_function_t)(double);
typedef double (*mathematical_constant_t)();

typedef struct {
	double An, Bn;
} fcoeff_t;

int n_term = 100;
double ll, ul, precision = 0.001;
char *flib_path = NULL, *progname = NULL, *lowerl = NULL, *upperl = NULL, *output = "text";
bool is_limit_exists = false, verbose = false, ognuplot = false, dump_terminal = false, formula = false;

void usage(const char* note)
{
	fputs(note, stderr);
	fprintf(stderr, "%s: F(x) [OPTION]... [-a] [-b]\n", progname);
	fputs("-h       Getting help\n", stderr);
	fputs("-a       Lower integral limit\n", stderr);
	fputs("-b       Upper integral limit\n", stderr);
	fputs("-v       Show more details\n", stderr);
	fputs("-p       Change precision of result\n", stderr);
	fputs("-n       Specify N in discret sum\n", stderr);
	fputs("-g       Generate gnuplot syntax output\n", stderr);
	fputs("-d       Show output in terminal (dump terminal)\n", stderr);
	fputs("-f       Just print formula and gnuplot syntax\n", stderr);

	exit(EXIT_FAILURE);
}

int generate_exp_sharedlib(char *math_exp)
{
	FILE *f;

	if (!(f = fopen("/tmp/exp.c", "w")))
		return (EXIT_FAILURE);

	fprintf(f,
	        "/* Generated by fourier.sh */\n"
	        "#include <math.h>\n"
	        "\n"
	        "double f(double x)\n"
	        "{\n"
	        "	return %s;\n"
	        "}\n"
	        "\n"
	        "double lowerl()\n"
	        "{\n"
	        "	return %s;\n"
	        "}\n"
	        "\n"
	        "double upperl()\n"
	        "{\n"
	        "	return %s;\n"
	        "}\n",
	        math_exp, lowerl, upperl
	       );
	fclose(f);

	system("cc -lm -shared -fPIC /tmp/exp.c -o /tmp/exp.so");
	flib_path = "/tmp/exp.so";
	return (EXIT_SUCCESS);
}

void parse_arguments(int argc, char **argv)
{
	int  c;

	progname = argv[0];
	while ((c = getopt(argc, argv, "fvgda:b:hp:n:")) != -1) {
		switch (c) {
		case 'a':
			lowerl = optarg;
			is_limit_exists = true;
			break;

		case 'b':
			upperl = optarg;
			is_limit_exists = true;
			break;

		case 'p':
			precision = atof(optarg);
			break;

		case 'n':
			n_term = atof(optarg);
			break;

		case 'v':
			verbose = true;
			break;

		case 'g':
			ognuplot = true;
			break;

		case 'd':
			dump_terminal = true;
			break;

		case 'f':
			formula = true;
			ognuplot = true;
			break;

		case 'h':
			usage("");
			break;

		case '?':
			fprintf(stderr, "Try '%s --help' for more information.", progname);
			exit(EXIT_FAILURE);
		}
	}

	argc -= optind;
	argv += optind;

	if (!is_limit_exists)
		usage("-a/-b is required. you should pass least one of limits!\n");

	if (!argv[0])
		usage("F(x): is required\n");

	if (generate_exp_sharedlib(argv[0])) {
		fprintf(stderr, "Unable to build shared library:%s\n", strerror(errno));
		exit(EXIT_FAILURE);
	}

	if (dump_terminal)
		ognuplot = 1;
}

fcoeff_t calculate_fourier_coefficient(mathematical_function_t f, double L, int N)
{
	fcoeff_t fc = {};

	for (double x = ll; x <= ul; x += precision)
		fc.An += (f(x) * cos(N * M_PI * x / L)) * precision;
	fc.An *= 1/L;

	for (double x = ll; x <= ul; x += precision)
		fc.Bn += (f(x) * sin(N * M_PI * x / L)) * precision;
	fc.Bn *= 1/L;

	fc.An = (signed long)(fc.An * 100000) * 0.00001f;
	fc.Bn = (signed long)(fc.Bn * 100000) * 0.00001f;

	return fc;
}

void plot_fourier_text(mathematical_function_t f)
{
	for (int n = 0; n < n_term; n++) {
		double L = (ul - ll)/2;
		fcoeff_t c = calculate_fourier_coefficient(f, L, n);

		printf(c.An ? "A%d = %f" : "", n, c.An);
		printf(c.An && c.Bn ? ", " : "");
		printf(c.Bn ? "B%d = %f" : "", n, c.Bn);
		printf(c.An || c.Bn ? "\n" : "");
	}
}

void plot_fourier_gnuplot(mathematical_function_t f)
{
	int pid, fds[2];
	char *const args[] = { "gnuplot", NULL };

	if (formula) {
		fds[1] = STDOUT_FILENO;
	} else {
		pipe(fds);
		close(STDIN_FILENO);
		dup2(fds[0], STDIN_FILENO);
	}

	if (!formula) {
		if (dump_terminal)
			dprintf(fds[1], "set terminal dumb;");

		dprintf(fds[1],
		        "set style line 12 lc rgb '#808080' lt 0 lw 1;"
		        "set grid back ls 12;"
		       );

		dprintf(fds[1], "plot 0");
	}

	for (int n = 0; n < n_term; n++) {
		double L = (ul - ll)/2;
		fcoeff_t c = calculate_fourier_coefficient(f, L, n);

		dprintf(fds[1], c.An ? "+%f*cos(x*%d*pi/%f)" : "", c.An, n, L);
		dprintf(fds[1], c.Bn ? "+%f*sin(x*%d*pi/%f)" : "", c.Bn, n, L);
	}

	if (formula) {
		dprintf(fds[1], "\n");
		return;
	}

	dprintf(fds[1], " title \"Fourier serie\"\n");

	pid = fork();
	if (pid == -1)
		fprintf(stderr, "unable to fork");
	else if (pid == 0)
		execvp("gnuplot", args);
}

int main(int argc, char **argv)
{
	void* dlobj = NULL;
	mathematical_function_t f = NULL;
	mathematical_constant_t cf = NULL;

	parse_arguments(argc, argv);

	if (!(dlobj = dlopen(flib_path, RTLD_LAZY))) {
		fprintf(stderr, "%s\n", dlerror());
		exit(EXIT_FAILURE);
	}

	if (!(f = dlsym(dlobj, "f"))) {
		fprintf(stderr, "%s\n", dlerror());
		exit(EXIT_FAILURE);
	}

	if (!(cf = dlsym(dlobj, "lowerl"))) {
		fprintf(stderr, "%s\n", dlerror());
		exit(EXIT_FAILURE);
	}
	ll = cf();

	if (!(cf = dlsym(dlobj, "upperl"))) {
		fprintf(stderr, "%s\n", dlerror());
		exit(EXIT_FAILURE);
	}
	ul = cf();

	if (ognuplot)
		plot_fourier_gnuplot(f);
	else
		plot_fourier_text(f);

	return (EXIT_SUCCESS);
}
